В чем разница между селектором по классу и по ID с точки зрения специфичности и возможности повторного использования?
Селектор по классу (.my-class):
Специфичность: Средняя (0-0-1-0). Меньше, чем у ID, но больше, чем у тега.
Повторное использование: Можно использовать сколько угодно раз на одной странице! Это его главное преимущество. Классы нужны для стилизации групп элементов.
Селектор по ID (#my-id):
Специфичность: Очень высокая (0-1-0-0). Выше, чем у класса и тега.
Повторное использование: Должен быть уникальным на странице! То есть, один ID – один элемент. Это его главный недостаток с точки зрения стилизации, но хорошо для якорей или JS-связей.
Итог: Классы для стилей, которые применяются ко многим элементам, ID – для уникальных элементов или для якорей/JS.
Как работает каскад в CSS и в каком порядке применяются стили при конфликте правил?
Каскад – это правила, по которым браузер решает, какой стиль применить к элементу, если к нему подходят несколько правил. Это как набор фильтров.
Порядок применения (от наименьшего приоритета к наибольшему):
Браузерные стили (User Agent Stylesheets): Дефолтные стили браузера (например, у <h1> по умолчанию большой шрифт).
Пользовательские стили (User Stylesheets): Стили, которые сам пользователь может настроить в браузере (редко, но бывает).
Авторские стили (Author Stylesheets): Наши стили в CSS-файле или <style>-теге.
Важные авторские стили (!important в авторских стилях): Правила с !important.
Важные пользовательские стили (!important в пользовательских стилях): Правила с !important от пользователя (очень редко).
При конфликте правил с одинаковым источником: Сначала смотрят на специфичность. Если специфичность одинаковая, то на порядок в коде – побеждает последнее объявленное правило.
Рассчитайте специфичность для селекторов:
ul li.important
Теги (ul, li): 2
Классы (.important): 1
ID: 0
Итого: 0-0-2-1 (0 ID, 0 классов, 2 тега, 1 псевдокласс/элемент - хотя тут нет псевдокласса/элемента, поэтому 0) -> 0-0-1-2 (1 класс, 2 тега)
#site-title
ID: 1
Теги/Классы: 0
Итого: 0-1-0-0
.content > .featured-post
Классы (.content, .featured-post): 2
Теги: 0
Итого: 0-0-2-0
(Маленькая поправка: специфичность считается как A-B-C-D, где A=inline-стили, B=ID, C=классы/псевдоклассы/атрибуты, D=теги/псевдоэлементы. Мои расчеты выше соответствуют этому.)
Какие свойства в CSS наследуются по умолчанию, а какие нет? Приведите по 3 примера каждого типа.
Наследуются (от родителя к потомку): В основном, свойства текста и цвета.
color (цвет текста)
font-family (шрифт)
font-size (размер шрифта)
line-height (высота строки)
text-align (выравнивание текста)
Не наследуются (нужно задавать явно для каждого элемента): В основном, блочные свойства и границы.
margin (внешние отступы)
padding (внутренние отступы)
border (границы)
width / height (ширина / высота)
background-color (цвет фона)
display (тип отображения элемента)
Как работает селектор > (дочерний селектор) и чем он отличается от селектора потомков (через пробел)?
Дочерний селектор (parent > child): Выбирает только непосредственных дочерних элементов. То есть, child должен быть прямым потомком parent, без других элементов между ними.
Пример: ul > li выберет li, которые прямо внутри ul. Не выберет li, если он внутри еще одного <div> внутри ul.
Селектор потомков (ancestor descendant): Выбирает любых потомков, независимо от уровня вложенности. descendant может быть вложен на любом уровне внутри ancestor.
Пример: ul li выберет все li, которые находятся внутри ul, даже если они вложены через несколько <div> или других списков.
Разница: > строже, выбирает только прямых детей. Пробел выбирает всех потомков.
Для чего используются псевдоклассы :hover и :nth-child()? В каких практических задачах они могут пригодиться?
:hover: Применяет стили, когда пользователь наводит курсор мыши на элемент.
Практические задачи: Изменение цвета ссылки/кнопки при наведении, появление всплывающих подсказок, эффекты при наведении на карточки товаров (например, увеличение тени).
:nth-child(n): Выбирает элементы, которые являются n-м дочерним элементом своего родителя. n может быть числом, even (четные), odd (нечетные), или формулой (2n+1).
Практические задачи: Чередование цвета строк в таблице (tr:nth-child(even)), выделение каждого третьего элемента списка, стилизация первого/последнего элемента в группе (:first-child, :last-child).
Что делает правило !important и почему его следует использовать с осторожностью?
!important (после значения свойства, например, color: red !important;) перебивает все остальные правила специфичности и каскада, кроме других !important с более высоким приоритетом (например, от пользовательских стилей).
Почему с осторожностью:
Ломает каскад: Делает CSS-код очень трудным для отладки и поддержки, так как !important создает "жесткие" правила, которые сложно переопределить.
Трудно поддерживать: Если нужно изменить стиль, придется использовать еще один !important, что ведет к "войне" !important и беспорядку в коде.
Для кого использовать: Иногда оправдано в очень специфичных случаях, например, для быстрого временного исправления или при работе со сторонними библиотеками, где нет другого способа переопределить стиль. В своей работе стараюсь избегать.
Как псевдоэлементы ::before и ::after расширяют возможности CSS и какой контент они могут содержать?
Они позволяют добавлять декоративный контент к элементу без изменения HTML-структуры. Это как будто мы вставляем виртуальный элемент до (::before) или после (::after) содержимого существующего HTML-элемента.
Расширяют возможности:
Декоративные иконки: Добавить иконку перед ссылкой или элементом списка.
Подчеркивания/линии: Создать анимированные подчеркивания или декоративные линии.
Кавычки: Автоматически добавлять кавычки к цитатам.
Очистка float: Использовать ::after для clearfix.
"Стрелки" у попапов: Создавать маленькие "хвостики" для всплывающих окон.
Какой контент: Основное свойство для них – content. Оно может содержать:
Строковый текст (content: "Hello";)
Пустую строку (content: "";) – часто используется для декоративных элементов.
Атрибуты элемента (content: attr(data-icon);)
Символы Unicode (content: "\201C"; для кавычек)
URL для изображений (content: url(icon.png);)
По сути, они создают инлайново-блочный элемент, который можно стилизовать как обычный div.
В каком порядке браузер применяет CSS-правила при одинаковой специфичности селекторов?
Если у двух или более правил одинаковая специфичность, браузер применяет их в порядке их появления в коде. Последнее объявленное правило "побеждает" и переопределяет предыдущие.
Это называется "правило порядка исходного кода".
Как инструменты разработчика в браузере помогают анализировать и отлаживать CSS-код?
Это просто спасение для любого верстальщика!
Просмотр примененных стилей: Показывают все CSS-правила, которые применяются к выбранному элементу, включая те, что унаследованы или переопределены. Видно, откуда берется стиль.
Изменение стилей в реальном времени: Можно менять значения свойств, добавлять/удалять правила прямо в браузере и сразу видеть результат, не перезагружая страницу. Очень удобно для экспериментов.
Расчет специфичности: Часто показывают специфичность селекторов.
Модель коробки (Box Model): Наглядно отображают margin, border, padding, content элемента, что помогает понять его размеры и отступы.
Поиск конфликтов: Показывают зачеркнутые правила, которые были переопределены другими, более специфичными или поздними правилами.
Анализ производительности: Помогают выявить медленные CSS-правила или анимации.
Медиа-запросы: Позволяют быстро переключаться между разными размерами экрана для тестирования адаптивности.